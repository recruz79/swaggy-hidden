
STEPS TO INSTALL THE PLUGIN
===========================

To make the plugin work there is need to configure some components inside the grails project.

	Grails Configuration:
	=====================
	On build.gradble add the following line in the dependencies closure to install the plugin.
	
	compile 'swaggy.hidden:swaggy-hidden:0.6'
	
	Spring configuration:
	=====================
	
	WPSwaggyDataService is the extended swaggyDataService which allows features to hide domain properties.
	ApiKeyFilter is the filter which intercepts the api_key params coming from swagger and includes it in the
	header request so Spring Security can intercept it and authenticate.
	
	There is needed to inject the beans below in the Resources.groovy file to make the plugin work.
	
	/**
     * We want APIController to inject our extended SwaggyDataService, WPSwaggyDataService
     * So we overwrite the swaggyDataService bean with our own implementation
     */
    swaggyDataService(WPSwaggyDataService){
        pluginSwaggyDataService = ref('pluginSwaggyDataService')
        grailsApplication = grails.util.Holders.getGrailsApplication()
    }
	
	Domain Configuration:
	=====================
	
	The HiddenApiRest annotation can be used on any domain class for hiding unwanted properties from domains so swagger will not show them
	in the api services screen, it supports multiple properties to hide and can be used as seen below.
	
	@HiddenApiRest(values = ["version", "address"])
	class Author {

		String name
		String address
		String phone
		String email
	}
	
	Controller configuration:
	=========================
	The plugin uses the swaggyDoc features to map controllers, for standard methods (create, index, update, save, edit) there is no need to
	add annotations they will be documented automatically, change them only if needed to add customization on them.
	
	@Api("Book Controller services")
	class BookController extends RestfulController {

		BookController(){
			super(Book)
		}

		@ApiOperation(value = "Returns an json list of Books domain", httpMethod = "GET", response = Book)
		def index(Integer max) {
			super.index(max)
		}

		@ApiOperation(value = "Updates an Book domain object", httpMethod = "PUT")
		@ApiResponses([
				@ApiResponse(code = 405, message = "Bad method. Only POST is allowed"),
				@ApiResponse(code = 401, message = "Unauthorized"),
				@ApiResponse(code = 400, message = "Invalid request json")
		])

		def update() {
			super.update()
		}
	}


	Scaffolding:
	============
	
	By creating scaffolding based on Domain resources there will be needed to modify the scaffolding templates for fixing the autogenerated controllers links
	since they collide using the rest services paths.
	
	<g:link> should not work and must be changed by <a> to set manually the urls as show below: 
	
	<g:link class="create" action="create"><g:message code="default.new.label" args="[entityName]" /></g:link>
	<a class="home" href="\${createLink(uri: '/')}/${entityName}/create"><g:message code="default.new.label" args="[entityName]" /></a>
	
	
	Setting mapping for Rest Services:
	==================================
	
	Swagger can detect rest resources by reading the UrlMappings.groovy file, the examples below are settings two rest artifacts
	which will be created using all the CRUD methods (save, show, update), notice that we are excluding unwanted methos from being
	shown in Swagger like create, edit and patch which are used by the scaffolding feature.
	
	static mappings = {
    
        "/rest/books" (resources:'book', excludes:['create', 'edit', 'patch']) { format = 'json' }
        "/rest/authors" (resources:'author', excludes:['create', 'edit', 'patch']) { format = 'json' }
    }

    Spring Security:
    ================

    Both types of authentication can work together in the same application Token and Login in the example below we are
    setting them to share the same path configuration where scaffolding will require login authentication and rest services
	will need token authentication.

    Tip:
        Remember to create the user domains (User, Role, etc..) and basic configuration on application.groovy by running 
		the command "grails s2-quickstart" 
		
    grails.plugin.springsecurity.useSecurityEventListener = true
    grails.plugin.springsecurity.userLookup.userDomainClassName = 'com.app.User'
    grails.plugin.springsecurity.userLookup.authorityJoinClassName = 'com.app.UserRole'
    grails.plugin.springsecurity.authority.className = 'com.app.Role'
    grails.plugin.springsecurity.password.algorithm='SHA-256'

    grails.plugin.springsecurity.rest.login.active = true
    grails.plugin.springsecurity.rest.login.failureStatusCode = 401

    grails.plugin.springsecurity.controllerAnnotations.staticRules = [
    		[pattern: '/error', access: ['permitAll']],
    		[pattern: '/index', access: ['permitAll']],
    		[pattern: '/index.gsp', access: ['permitAll']],
    		[pattern: '/shutdown', access: ['permitAll']],
    		[pattern: '/assets/**', access: ['permitAll']],
    		[pattern: '/**/js/**', access: ['permitAll']],
    		[pattern: '/**/css/**', access: ['permitAll']],
    		[pattern: '/**/images/**', access: ['permitAll']],
    		[pattern: '/**/favicon.ico', access: ['permitAll']],
    		[pattern: '/rest/**', access: ['permitAll']],
    		[pattern: '/rest/public/**', access: ['permitAll']],
    		[pattern: '/api/**', access: ['permitAll']]
    ]

    grails.plugin.springsecurity.filterChain.chainMap = [
    		//Public chain
    		[
    				pattern: '/rest/public/**',
    				filters: 'anonymousAuthenticationFilter,restTokenValidationFilter,restExceptionTranslationFilter,filterInvocationInterceptor'
    		],
    		//Stateless chain
    		[
    				pattern: '/rest/**',
    				filters: 'JOINED_FILTERS,-anonymousAuthenticationFilter,-exceptionTranslationFilter,-authenticationProcessingFilter,-securityContextPersistenceFilter,-rememberMeAuthenticationFilter'
    		],
    		//Traditional chain
    		[
    				pattern: '/**',
    				filters: 'JOINED_FILTERS,-restTokenValidationFilter,-restExceptionTranslationFilter'
    		]
    ]
